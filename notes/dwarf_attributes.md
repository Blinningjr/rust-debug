# DWARF format version 4 Attributes

## DW\_AT\_abstract\_origin <!--- NOTE: Currently used in my debugger -->
This attribute can be found in dies that have been inlined such as dies with the tag `DW_TAG_subprogram`, `DW_TAG_variable` and more.
These inlined dies are part of a pair of dies, the inlined die is the one that will contain location information for variable dies and a pointer to the other die in the pair, the pointer is under the attribute `DW_AT_abstract_origin`.
The other die in the pair will contain the rest of the information that a variable die contains.

Thus when in my debugger when I evaluate a inlined variable I start by retrieving the location information from the inlined die.
Then I use the attribute `DW_AT_abstract_origin` to find the other die in the pair and retrieve the rest of the information I need from that die.

This is partly how `DW_AT_abstract_origin` is described in DWARF 4, page 61:

> "Concrete inlined instance entries may omit attributes that are not specific to the concrete instance (but present in the abstract instance) and need include only attributes that are specific to the concrete instance (but omitted in the abstract instance).
> In place of these omitted attributes, each concrete inlined instance entry has a `DW_AT_abstract_origin` attribute that may be used to obtain the missing information (indirectly) from the associated abstract instance entry.
> The value of the abstract origin attribute is a reference to the associated abstract instance entry."


## DW\_AT\_accessibility <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_accessibility` is described in DWARF 4, page 32:

> "The accessibility of a declaration is represented by a `DW_AT_accessibility` attribute, whose value is a constant drawn from the set of codes listed in Figure 4."


## DW\_AT\_address\_class <!--- NOTE: This is not applicable to my debugger -->
This attribute can be found under dies that describe pointers and thus is always present in dies with the tag `DW_TAG_pointer_type`.
The value of this attribute is a enum that describes how the address of this pointer should be read and used.
The values of the enum is target specific except for the value `DW_ADDR_none` = **0** which means that no address class is specified.

In Rust there never seem to be any segmented addresses thus the value of this attribute is always `DW_ADDR_none` and can be ignored for now. <!--- TODO: Update and confirm  -->

This is partly how `DW_AT_address_class` is described in DWARF 4, page 34:

> "Any debugging information entry representing a pointer or reference type or a subroutine or subroutine type may have a `DW_AT_address_class` attribute, whose value is an integer constant.
> The set of permissible values is specific to each target architecture.
> The value `DW_ADDR_none`, however, is common to all encodings, and means that no address class has been specified."


## DW\_AT\_allocated <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust, probably because Rust doesn't have dynamically allocated data types.

This is partly how `DW_AT_allocated` is described in DWARF 4, page 102:

> "The `DW_AT_allocated` attribute may optionally be used with any type for which objects of the type can be explicitly allocated and deallocated.
> The presence of the attribute indicates that objects of the type are allocatable and deallocatable.
> The integer value of the attribute (see below) specifies whether an object of the type is currently allocated or not."


## DW\_AT\_artificial <!--- TODO: Don't know how to use this info. -->
Tells the user that the die with this attribute is created by the compiler and is not specifically declared in the source file.

This is partly how `DW_AT_artificial` is described in DWARF 4, page 34:

> "Any debugging information entry representing the declaration of an object or type artificially generated by a compiler and not explicitly declared by the source program may have a `DW_AT_artificial` attribute, which is a flag."


## DW\_AT\_associated <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust, probably because Rust doesn't have dynamically allocated data types.

This is partly how `DW_AT_associated` is described in DWARF 4, page 102:

> "The `DW_AT_associated` attribute may optionally be used with any type for which objects of the type can be dynamically associated with other objects.
> The presence of the attribute indicates that objects of the type can be associated.
> The integer value of the attribute (see below) indicates whether an object of the type is currently associated or not."


## DW\_AT\_base\_types <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_base_types` is described in DWARF 4, page 47:

> "A `DW_AT_base_types` attribute whose value is a reference.
> <br/><br/>
> This attribute points to a debugging information entry representing another compilation unit.
> It may be used to specify the compilation unit containing the base type entries used by entries in the current compilation unit (see Section 5.1).
> <br/><br/>
> This attribute provides a consumer a way to find the definition of base types for a
compilation unit that does not itself contain such definitions.
> This allows a consumer, for example, to interpret a type conversion to a base type correctly."


## DW\_AT\_binary\_scale <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_binary_scale` is described in DWARF 4, page 79:

> "For a data type with a binary scale factor, the fixed binary type entry has a `DW_AT_binary_scale` attribute.
> The `DW_AT_binary_scale` attribute is an integer constant value that represents the exponent of the base two scale factor to be applied to an instance of the type.
> Zero scale puts the binary point immediately to the right of the least significant bit.
> Positive scale moves the binary point to the right and implies that additional zero bits on the right are not stored in an instance of the type.
> Negative scale moves the binary point to the left; if the absolute value of the scale is larger than the number of bits, this implies additional zero bits on the left are not stored in an instance of the type."


## DW\_AT\_bit\_offset <!--- NOTE: Not applicable to my debugger -->
This attribute is deprecated in version 4 of dwarf and it seems to not be used by Rust.

This is partly how `DW_AT_bit_offset` is described in DWARF 4, page 76:

> "The attribute `DW_AT_bit_offset` is deprecated in DWARF Version 4 for use in base types, but implementations may continue to support its use for compatibility."


## DW\_AT\_bit\_size <!--- TODO: Check if this is correct -->
This seems to not be used by Rust.

This is partly how `DW_AT_bit_size` is described in DWARF 4, page 41:

> "Many debugging information entries allow either a `DW_AT_byte_size` attribute or a `DW_AT_bit_size` attribute, whose integer constant value (see Section ) specifies an amount of storage.
> The value of the `DW_AT_byte_size` attribute is interpreted in bytes and the value of the `DW_AT_bit_size` attribute is interpreted in bits."


## DW\_AT\_bit\_stride <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_bit_stride` is described in DWARF 4, page 83:

> "If the amount of storage allocated to hold each element of an object of the given array type is different from the amount of storage that is normally allocated to hold an individual object of the indicated element type, then the array type entry has either a `DW_AT_byte_stride` or a `DW_AT_bit_stride` attribute, whose value (see Section 2.19) is the size of each element of the array."


## DW\_AT\_byte\_size <!--- TODO: Might be more uses for this. -->
This attribute describes the size of a type in bytes and is found in every type die.
One of the most useful uses of this attribute is to know how many bytes to read from a address when evaluating the value of a object.
In my debugger I use this attribute only for evaluating dies with the tag `DW_AT_base_type` because the larger data types can be divided into multiple base types.
And the byte size if also needed for parsing the size of a integer, for example a singed integer with byte size one will be parsed into a **i8**.

This is partly how `DW_AT_byte_size` is described in DWARF 4, page 41:

> "Many debugging information entries allow either a `DW_AT_byte_size` attribute or a `DW_AT_bit_size` attribute, whose integer constant value (see Section ) specifies an amount of storage.
> The value of the `DW_AT_byte_size` attribute is interpreted in bytes and the value of the `DW_AT_bit_size` attribute is interpreted in bits."


## DW\_AT\_byte\_stride <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_byte_stride` is described in DWARF 4, page 83:

> "If the amount of storage allocated to hold each element of an object of the given array type is different from the amount of storage that is normally allocated to hold an individual object of the indicated element type, then the array type entry has either a `DW_AT_byte_stride` or a `DW_AT_bit_stride` attribute, whose value (see Section 2.19) is the size of each element of the array."


## DW\_AT\_call\_column <!--- TODO: confirm that unit.line_program gives same result -->
The column where the inlined function is called from in the source file.

This is partly how `DW_AT_call_column` is described in DWARF 4, page 60:

> "An inlined subroutine entry may also have `DW_AT_call_file`, `DW_AT_call_line` and `DW_AT_call_column` attributes, each of whose value is an integer constant.
> These attributes represent the source file, source line number, and source column number, respectively, of the first character of the statement or expression that caused the inline expansion.
> The call file, call line, and call column attributes are interpreted in the same way as the declaration file, declaration line, and declaration column attributes, respectively (see Section 2.14)."


## DW\_AT\_call\_file <!--- TODO: confirm that unit.line_program gives same result -->
The source file which the inlined function is called from.

This is partly how `DW_AT_call_file` is described in DWARF 4, page 60:

> "An inlined subroutine entry may also have `DW_AT_call_file`, `DW_AT_call_line` and `DW_AT_call_column` attributes, each of whose value is an integer constant.
> These attributes represent the source file, source line number, and source column number, respectively, of the first character of the statement or expression that caused the inline expansion.
> The call file, call line, and call column attributes are interpreted in the same way as the declaration file, declaration line, and declaration column attributes, respectively (see Section 2.14)."


## DW\_AT\_call\_line <!--- TODO: confirm that unit.line_program gives same result -->
The line where the inlined function is called from in the source file.

This is partly how `DW_AT_call_line` is described in DWARF 4, page 60:

> "An inlined subroutine entry may also have `DW_AT_call_file`, `DW_AT_call_line` and `DW_AT_call_column` attributes, each of whose value is an integer constant.
> These attributes represent the source file, source line number, and source column number, respectively, of the first character of the statement or expression that caused the inline expansion.
> The call file, call line, and call column attributes are interpreted in the same way as the declaration file, declaration line, and declaration column attributes, respectively (see Section 2.14)."


## `DW_AT_calling_convention` TODO
## `DW_AT_common_reference` TODO
## `DW_AT_comp_dir` TODO
## `DW_AT_const_value` TODO
## `DW_AT_const_expr` TODO


## `DW_AT_containing_type` <!-- TODO: Implement this like `DW_AT_type` I think -->
This attributes seems to mean that a variable points to a structures attribute.
It is found under the type tags, for example type tag `DW_TAG_structure_type`.
This is how the type of the values in the **vtable** is presented in the dwarf file.

This is how it is described in DWARF 4, page 100:

> "The pointer to member entry also has a `DW_AT_containing_type` attribute, whose value is a reference to a debugging information entry for the class or structure to whose members objects of this type may point."


## `DW_AT_count` TODO
## `DW_AT_data_bit_offset` TODO
## `DW_AT_data_location` TODO
## `DW_AT_data_member_location` TODO
## `DW_AT_decimal_scale` TODO
## `DW_AT_decimal_sign` TODO
## `DW_AT_decl_column` TODO
## `DW_AT_decl_file` TODO
## `DW_AT_decl_line` TODO
## `DW_AT_declaration` TODO
## `DW_AT_default_value` TODO
## `DW_AT_description` TODO


## `DW_AT_digit_count` TODO
## `DW_AT_discr` TODO
## `DW_AT_discr_list` TODO
## `DW_AT_discr_value` TODO
## `DW_AT_elemental` TODO
## `DW_AT_encoding` TODO
## `DW_AT_endianity` TODO
## `DW_AT_entry_pc` TODO
## `DW_AT_enum_class` TODO
## `DW_AT_explicit` TODO
## `DW_AT_extension` TODO


## `DW_AT_external` <!--- TODO: Use this to show visibility of functions and variables -->
This attributes is to show if a function or variable is visible outside of its compilation unit.
It can be found in dies with the tags `DW_TAG_subprogram` and `DW_TAG_variable`.

This is how it is described for Subroutines in DWARF 4, page 53:

> "If the name of the subroutine described by an entry with the tag `DW_TAG_subprogram` is visible outside of its containing compilation unit, that entry has a `DW_AT_external` attribute, which is a flag."

This is how it is described for Variables in DWARF 4, page 70:

> "If the variable entry represents a non-defining declaration, `DW_AT_specification` may be used to reference the defining declaration of the variable.
> If no `DW_AT_specification` attribute is present, the defining declaration may be found as a global definition either in the current compilation unit or in another compilation unit with the `DW_AT_external` attribute."


## `DW_AT_frame_base` TODO
## `DW_AT_friend` TODO
## `DW_AT_high_pc` TODO
## `DW_AT_identifier_case` TODO
## `DW_AT_import` TODO


## `DW_AT_inline` <!--- TODO: Used this to show what functions got inlined -->
This attribute can be used in to ways, the first is to declare an instance abstract, the other way so to describe if a function got inlined or not. 

This is partly how **Abstract Instances** is described in DWARF 4, page 59:

> "Any debugging information entry that is owned (either directly or indirectly) by a debugging information entry that contains the `DW_AT_inline` attribute is referred to as an “abstract instance entry.”
> Any subroutine entry that contains a `DW_AT_inline` attribute whose value is other than `DW_INL_not_inlined` is known as an “abstract instance root.”"

This is how **Inlined Subroutines** is described in DWARF 4, page 58:

> "A declaration or a definition of an inlinable subroutine is represented by a debugging information entry with the tag `DW_TAG_subprogram`.
> The entry for a subroutine that is explicitly declared to be available for inline expansion or that was expanded inline implicitly by the compiler has a `DW_AT_inline` attribute whose value is an integer constant.
> The set of values for the `DW_AT_inline` attribute is given in Figure 11."


## `DW_AT_is_optional` TODO
## `DW_AT_language` TODO
## `DW_AT_linkage_name` TODO
## `DW_AT_location` TODO
## `DW_AT_low_pc` TODO
## `DW_AT_lower_bound` TODO
## `DW_AT_macro_info` TODO
## `DW_AT_main_subprogram` TODO
## `DW_AT_mutable` TODO
## `DW_AT_name` TODO
## `DW_AT_namelist_item` TODO
## `DW_AT_object_pointer` TODO
## `DW_AT_ordering` TODO
## `DW_AT_picture_string` TODO
## `DW_AT_priority` TODO


## `DW_AT_producer` <!--- TODO: Use this attribute in my debugger somehow. -->
Describes which compiler that generated this DWARF compilation unit and which version of the compiler that was used.
This attributes is only found in the dies with the tag `DW_TAG_compile_unit`.

This is how it is described in DWARF 4, page 46:

> "A `DW_AT_producer` attribute whose value is a null-terminated string containing information about the compiler that produced the compilation unit.
> The actual contents of the string will be specific to each producer, but should begin with the name of the compiler vendor or some other identifying character sequence that should avoid confusion with other producer values."


## `DW_AT_prototyped` <!--- NOTE: Not applicable to my debugger -->
This seams to be a thing in **C** functions and thus is not used in rust.

This is how it is described in DWARF 4, page 54:

> "A subroutine entry declared with a function prototype style declaration may have a `DW_AT_prototyped` attribute, which is a flag."

This is how it is described in DWARF 4, page 97:

> "A subroutine entry declared with a function prototype style declaration may have a `DW_AT_prototyped` attribute, which is a flag."


## `DW_AT_pure` TODO
## `DW_AT_ranges` TODO


## `DW_AT_recursive` TODO
## `DW_AT_return_addr` TODO
## `DW_AT_segment` TODO
## `DW_AT_sibling` TODO
## `DW_AT_small` TODO
## `DW_AT_signature` TODO
## `DW_AT_specification` TODO
## `DW_AT_start_scope` TODO
## `DW_AT_static_link` TODO


## `DW_AT_stmt_list` <!--- NOTE: I use unit.line_program from gimli-rs instead -->
This attribute is only found in dies with the tag `DW_TAG_compile_unit` and its value is a offset to the line number information.

This is how it is described in DWARF 4, page 45:

> "A `DW_AT_stmt_list` attribute whose value is a section offset to the line number information for this compilation unit.
> This information is placed in a separate object file section from the debugging information entries themselves.
> The value of the statement list attribute is the offset in the .debug\_line section of the first byte of the line number information for this compilation unit (see Section 6.2)."


## `DW_AT_string_length` <!--- NOTE: Not applicable to my debugger -->
Doesn't seem to be used by Rust.

This is how it is described in DWARF 4, page 98:

> "The string type entry may have a `DW_AT_string_length` attribute whose value is a location description yielding the location where the length of the string is stored in the program."


## `DW_AT_threads_scaled` TODO
## `DW_AT_trampoline` TODO
## `DW_AT_type` TODO
## `DW_AT_upper_bound` TODO
## `DW_AT_use_location` TODO
## `DW_AT_use_UTF8` TODO
## `DW_AT_variable_parameter` TODO
## `DW_AT_virtuality` TODO


## `DW_AT_visibility` TODO
## `DW_AT_vtable_elem_location` TODO

