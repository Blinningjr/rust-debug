# DWARF format version 4 Attributes

## DW\_AT\_abstract\_origin <!--- NOTE: Currently used in my debugger -->
This attribute can be found in dies that have been inlined such as dies with the tag `DW_TAG_subprogram`, `DW_TAG_variable` and more.
These inlined dies are part of a pair of dies, the inlined die is the one that will contain location information for variable dies and a pointer to the other die in the pair, the pointer is under the attribute `DW_AT_abstract_origin`.
The other die in the pair will contain the rest of the information that a variable die contains.

Thus when in my debugger when I evaluate a inlined variable I start by retrieving the location information from the inlined die.
Then I use the attribute `DW_AT_abstract_origin` to find the other die in the pair and retrieve the rest of the information I need from that die.

This is partly how `DW_AT_abstract_origin` is described in DWARF 4, page 61:

> "Concrete inlined instance entries may omit attributes that are not specific to the concrete instance (but present in the abstract instance) and need include only attributes that are specific to the concrete instance (but omitted in the abstract instance).
> In place of these omitted attributes, each concrete inlined instance entry has a `DW_AT_abstract_origin` attribute that may be used to obtain the missing information (indirectly) from the associated abstract instance entry.
> The value of the abstract origin attribute is a reference to the associated abstract instance entry."


## DW\_AT\_accessibility <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_accessibility` is described in DWARF 4, page 32:

> "The accessibility of a declaration is represented by a `DW_AT_accessibility` attribute, whose value is a constant drawn from the set of codes listed in Figure 4."


## DW\_AT\_address\_class <!--- NOTE: This is not applicable to my debugger -->
This attribute can be found under dies that describe pointers and thus is always present in dies with the tag `DW_TAG_pointer_type`.
The value of this attribute is a enum that describes how the address of this pointer should be read and used.
The values of the enum is target specific except for the value `DW_ADDR_none` = **0** which means that no address class is specified.

In Rust there never seem to be any segmented addresses thus the value of this attribute is always `DW_ADDR_none` and can be ignored for now. <!--- TODO: Update and confirm  -->

This is partly how `DW_AT_address_class` is described in DWARF 4, page 34:

> "Any debugging information entry representing a pointer or reference type or a subroutine or subroutine type may have a `DW_AT_address_class` attribute, whose value is an integer constant.
> The set of permissible values is specific to each target architecture.
> The value `DW_ADDR_none`, however, is common to all encodings, and means that no address class has been specified."


## DW\_AT\_allocated <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust, probably because Rust doesn't have dynamically allocated data types.

This is partly how `DW_AT_allocated` is described in DWARF 4, page 102:

> "The `DW_AT_allocated` attribute may optionally be used with any type for which objects of the type can be explicitly allocated and deallocated.
> The presence of the attribute indicates that objects of the type are allocatable and deallocatable.
> The integer value of the attribute (see below) specifies whether an object of the type is currently allocated or not."


## DW\_AT\_artificial <!--- TODO: Don't know how to use this info. -->
Tells the user that the die with this attribute is created by the compiler and is not specifically declared in the source file.

This is partly how `DW_AT_artificial` is described in DWARF 4, page 34:

> "Any debugging information entry representing the declaration of an object or type artificially generated by a compiler and not explicitly declared by the source program may have a `DW_AT_artificial` attribute, which is a flag."


## DW\_AT\_associated <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust, probably because Rust doesn't have dynamically allocated data types.

This is partly how `DW_AT_associated` is described in DWARF 4, page 102:

> "The `DW_AT_associated` attribute may optionally be used with any type for which objects of the type can be dynamically associated with other objects.
> The presence of the attribute indicates that objects of the type can be associated.
> The integer value of the attribute (see below) indicates whether an object of the type is currently associated or not."


## DW\_AT\_base\_types <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_base_types` is described in DWARF 4, page 47:

> "A `DW_AT_base_types` attribute whose value is a reference.
> <br/><br/>
> This attribute points to a debugging information entry representing another compilation unit.
> It may be used to specify the compilation unit containing the base type entries used by entries in the current compilation unit (see Section 5.1).
> <br/><br/>
> This attribute provides a consumer a way to find the definition of base types for a
compilation unit that does not itself contain such definitions.
> This allows a consumer, for example, to interpret a type conversion to a base type correctly."


## DW\_AT\_binary\_scale <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_binary_scale` is described in DWARF 4, page 79:

> "For a data type with a binary scale factor, the fixed binary type entry has a `DW_AT_binary_scale` attribute.
> The `DW_AT_binary_scale` attribute is an integer constant value that represents the exponent of the base two scale factor to be applied to an instance of the type.
> Zero scale puts the binary point immediately to the right of the least significant bit.
> Positive scale moves the binary point to the right and implies that additional zero bits on the right are not stored in an instance of the type.
> Negative scale moves the binary point to the left; if the absolute value of the scale is larger than the number of bits, this implies additional zero bits on the left are not stored in an instance of the type."


## DW\_AT\_bit\_offset <!--- NOTE: Not applicable to my debugger -->
This attribute is deprecated in version 4 of dwarf and it seems to not be used by Rust.

This is partly how `DW_AT_bit_offset` is described in DWARF 4, page 76:

> "The attribute `DW_AT_bit_offset` is deprecated in DWARF Version 4 for use in base types, but implementations may continue to support its use for compatibility."


## DW\_AT\_bit\_size <!--- TODO: Check if this is correct -->
This seems to not be used by Rust.

This is partly how `DW_AT_bit_size` is described in DWARF 4, page 41:

> "Many debugging information entries allow either a `DW_AT_byte_size` attribute or a `DW_AT_bit_size` attribute, whose integer constant value (see Section ) specifies an amount of storage.
> The value of the `DW_AT_byte_size` attribute is interpreted in bytes and the value of the `DW_AT_bit_size` attribute is interpreted in bits."


## DW\_AT\_bit\_stride <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_bit_stride` is described in DWARF 4, page 83:

> "If the amount of storage allocated to hold each element of an object of the given array type is different from the amount of storage that is normally allocated to hold an individual object of the indicated element type, then the array type entry has either a `DW_AT_byte_stride` or a `DW_AT_bit_stride` attribute, whose value (see Section 2.19) is the size of each element of the array."


## DW\_AT\_byte\_size <!--- TODO: Might be more uses for this. -->
This attribute describes the size of a type in bytes and is found in every type die.
One of the most useful uses of this attribute is to know how many bytes to read from a address when evaluating the value of a object.
In my debugger I use this attribute only for evaluating dies with the tag `DW_AT_base_type` because the larger data types can be divided into multiple base types.
And the byte size if also needed for parsing the size of a integer, for example a singed integer with byte size one will be parsed into a **i8**.

This is partly how `DW_AT_byte_size` is described in DWARF 4, page 41:

> "Many debugging information entries allow either a `DW_AT_byte_size` attribute or a `DW_AT_bit_size` attribute, whose integer constant value (see Section ) specifies an amount of storage.
> The value of the `DW_AT_byte_size` attribute is interpreted in bytes and the value of the `DW_AT_bit_size` attribute is interpreted in bits."


## DW\_AT\_byte\_stride <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_byte_stride` is described in DWARF 4, page 83:

> "If the amount of storage allocated to hold each element of an object of the given array type is different from the amount of storage that is normally allocated to hold an individual object of the indicated element type, then the array type entry has either a `DW_AT_byte_stride` or a `DW_AT_bit_stride` attribute, whose value (see Section 2.19) is the size of each element of the array."


## DW\_AT\_call\_column <!--- TODO: confirm that unit.line_program gives same result -->
The column where the inlined function is called from in the source file.

This is partly how `DW_AT_call_column` is described in DWARF 4, page 60:

> "An inlined subroutine entry may also have `DW_AT_call_file`, `DW_AT_call_line` and `DW_AT_call_column` attributes, each of whose value is an integer constant.
> These attributes represent the source file, source line number, and source column number, respectively, of the first character of the statement or expression that caused the inline expansion.
> The call file, call line, and call column attributes are interpreted in the same way as the declaration file, declaration line, and declaration column attributes, respectively (see Section 2.14)."


## DW\_AT\_call\_file <!--- TODO: confirm that unit.line_program gives same result -->
The source file which the inlined function is called from.

This is partly how `DW_AT_call_file` is described in DWARF 4, page 60:

> "An inlined subroutine entry may also have `DW_AT_call_file`, `DW_AT_call_line` and `DW_AT_call_column` attributes, each of whose value is an integer constant.
> These attributes represent the source file, source line number, and source column number, respectively, of the first character of the statement or expression that caused the inline expansion.
> The call file, call line, and call column attributes are interpreted in the same way as the declaration file, declaration line, and declaration column attributes, respectively (see Section 2.14)."


## DW\_AT\_call\_line <!--- TODO: confirm that unit.line_program gives same result -->
The line where the inlined function is called from in the source file.

This is partly how `DW_AT_call_line` is described in DWARF 4, page 60:

> "An inlined subroutine entry may also have `DW_AT_call_file`, `DW_AT_call_line` and `DW_AT_call_column` attributes, each of whose value is an integer constant.
> These attributes represent the source file, source line number, and source column number, respectively, of the first character of the statement or expression that caused the inline expansion.
> The call file, call line, and call column attributes are interpreted in the same way as the declaration file, declaration line, and declaration column attributes, respectively (see Section 2.14)."


## DW\_AT\_calling\_convention <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_calling_convention` is described in DWARF 4, page 54:

> "A subroutine entry may contain a `DW_AT_calling_convention` attribute, whose value is an integer constant.
> The set of calling convention codes is given in Figure 10."
> <br></br>
> ...
> <br></br>
> If this attribute is not present, or its value is the constant `DW_CC_normal`, then the subroutine may be safely called by obeying the “standard” calling conventions of the target architecture.
> If the value of the calling convention attribute is the constant `DW_CC_nocall`, the subroutine does not obey standard calling conventions, and it may not be safe for the debugger to call this subroutine. 


## DW\_AT\_common\_reference <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_common_reference` is described in DWARF 4, page 56:

> "The entry for a subroutine that includes a Fortran common block has a child entry with the tag `DW_TAG_common_inclusion`.
> The common inclusion entry has a `DW_AT_common_reference` attribute whose value is a reference to the debugging information entry for the common block being included (see Section 4.2)."


## DW\_AT\_comp\_dir <!--- NOTE: Used in my debugger -->
This attribute can always be found in dies with the tag `DW_TAG_compile_unit`, it contains the name of the compilation directory for this compile unit.

This is partly how `DW_AT_comp_dir` is described in DWARF 4, page 46:

> "A `DW_AT_comp_dir` attribute whose value is a null-terminated string containing the current working directory of the compilation command that produced this compilation unit in whatever form makes sense for the host system."


## DW\_AT\_const\_value <!--- TODO: Implement solution for constant object if they exist in rust. -->
The `DW_AT_const_value` attribute can used in three different ways, but I have only seen it in dies with the tag `DW_TAG_enumerator`.
In that case the attributes holds value of that enumerator and thus can be used to determine which enumerator the variable is.
This is done by comparing the value evaluated from the parent die with tag `DW_TAG_enumeration_type` and the values of the `DW_AT_const_value` attributes of all the `DW_TAG_enumerator` children dies.

This is partly how `DW_AT_const_value` is described in DWARF 4, page 96:

> "Each enumerator entry has a `DW_AT_name` attribute, whose value is a null-terminated string containing the name of the enumeration literal as it appears in the source program.
> Each enumerator entry also has a `DW_AT_const_value` attribute, whose value is the actual numeric value of the enumerator as represented on the target system."


## DW\_AT\_const\_expr <!--- TODO: Confirm  -->
This seems to not be used by Rust.

This is partly how `DW_AT_const_expr` is described in DWARF 4, page 60:

> "An inlined subroutine entry may have a `DW_AT_const_expr` attribute, which is a flag whose
presence indicates that the subroutine has been evaluated as a compile-time constant.
> Such an entry may also have a `DW_AT_const_value` attribute, whose value may be of any form that is appropriate for the representation of the subroutine's return value.
> The value of this attribute is the actual return value of the subroutine, represented as it would be on the target architecture."

This is partly how `DW_AT_const_expr` is described in DWARF 4, page 72:

> "A `DW_AT_const_expr` attribute, which is a flag, if a variable entry represents a C++ object declared with the *constexpr* specifier.
> This attributes indicates that the variable can be evaluated as a compile-time constant."


## DW\_AT\_containing\_type <!-- TODO: Implement this like `DW_AT_type` I think -->
This attributes seems to mean that a variable points to a structures attribute.
It is found under the type tags, for example type tag `DW_TAG_structure_type`.
This is how the type of the values in the **vtable** is presented in the dwarf file.

This is partly how `DW_AT_containing_type` is described in DWARF 4, page 100:

> "The pointer to member entry also has a `DW_AT_containing_type` attribute, whose value is a reference to a debugging information entry for the class or structure to whose members objects of this type may point."


## DW\_AT\_count <!--- TODO: Check if rust used `DW_TAG_shared_type` NOTE: Is used in my debugger. -->
This attribute can be found under the die with the tag `DW_TAG_subrange_type` and describes the number of elements in the subrange.
In my debugger I use this to find out the number of elements in a array that needs to be evaluated if it is present.

This is partly how `DW_AT_at_count` is described in DWARF 4, page 99:

> "The subrange entry may have the attributes `DW_AT_lower_bound` and `DW_AT_upper_bound` to specify, respectively, the lower and upper bound values of the subrange.
> The `DW_AT_upper_bound` attribute may be replaced by a `DW_AT_count` attribute, whose value describes the number of elements in the subrange rather than the value of the last element.
> The value of each of these attributes is determined as described in Section 2.19."


## DW\_AT\_data\_bit\_offset <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_data_bit_offset` is described in DWARF 4, page 75-76:

> "If the value of an object of the given type does not fully occupy the storage described by a byte size attribute, the base type entry may also have a `DW_AT_bit_size` and a `DW_AT_data_bit_offset` attribute, both of whose values are integer constant values (see Section
2.19).
> The bit size attribute describes the actual size in bits used to represent values of the given type.
> The data bit offset attribute is the offset in bits from the beginning of the containing storage to the beginning of the value.
> Bits that are part of the offset are padding.
> The data bit offset uses the bit numbering and direction conventions that are appropriate to the current language on the target system to locate the beginning of the storage and value.
> If this attribute is omitted a default data bit offset of zero is assumed."


## DW\_AT\_data\_location <!--- TODO: Confirm, NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_data_location` is described in DWARF 4, page 102:

> "The `DW_AT_data_location` attribute may be used with any type that provides one or more levels of hidden indirection and/or run-time parameters in its representation.
> Its value is a location description.
> The result of evaluating this description yields the location of the data for an object.
> When this attribute is omitted, the address of the data is the same as the address of the object."


## DW\_AT\_data\_member\_location <!--- NOTE: I use this in my debugger -->
The attribute `DW_AT_data_member_location` can be found in dies with the tag `DW_TAG_member`.
It is used as an offset to the address of the data structure that the member die is a child to.
Thus this attribute can be used to calculate the address of the member by adding its value the parents address.

This is partly how `DW_AT_data_member_location` is described in DWARF 4, page 88:

> "The member entry corresponding to a data member that is defined in a structure, union or class may have either a `DW_AT_data_member_location` attribute or a `DW_AT_data_bit_offset` attribute.
> If the beginning of the data member is the same as the beginning of the containing
entity then neither attribute is required."


## DW\_AT\_decimal\_scale <!--- TODO: Confirm  -->
This seems to not be used by Rust.

This is partly how `DW_AT_decimal_scale` is described in DWARF 4, page 78:

> "The `DW_AT_decimal_scale` attribute is an integer constant value that represents the exponent of the base ten scale factor to be applied to an instance of the type.
> A scale of zero puts the decimal point immediately to the right of the least significant digit.
> Positive scale moves the decimal point to the right and implies that additional zero digits on the right are not stored in an instance of the type.
> Negative scale moves the decimal point to the left; if the absolute value of the scale is larger than the digit count, this implies additional zero digits on the left are not stored in an instance of the type."


## `DW_AT_decimal_sign` <!--- TODO: Confirm  -->
This seems to not be used by Rust.

This is partly how `DW_AT_decimal_sign` is described in DWARF 4, page 78:

> "A `DW_AT_decimal_sign` attribute is an integer constant that conveys the representation of the sign of the decimal type (see Figure 14).
> Its integer constant value is interpreted to mean that the type has a leading overpunch, trailing overpunch, leading separate or trailing separate sign representation or, alternatively, no sign at all."


## DW\_AT\_decl\_column <!--- NOTE: I use this in my debugger -->
The attribute `DW_AT_decl_column` has the source file column number that this die is generated from.

This is partly how `DW_AT_decl_column` is described in DWARF 4, page 36:

> "The value of the `DW_AT_decl_column` attribute represents the source column number at which the first character of the identifier of the declared object appears.
> The value 0 indicates that no column has been specified."


## DW\_AT\_decl\_file <!--- NOTE: I use this in my debugger -->
The attribute `DW_AT_decl_column` has the source file name that this die is generated from.

This is partly how `DW_AT_decl_file` is described in DWARF 4, page 36:

> "The value of the `DW_AT_decl_file` attribute corresponds to a file number from the line number information table for the compilation unit containing the debugging information entry and represents the source file in which the declaration appeared (see Section ).
> The value 0 indicates that no source file has been specified."


## DW\_AT\_decl\_line <!--- NOTE: I use this in my debugger -->
The attribute `DW_AT_decl_column` has the source file line number that this die comes from and it can be found in any die.

This is partly how `DW_AT_decl_line` is described in DWARF 4, page 36:

> "The value of the `DW_AT_decl_line` attribute represents the source line number at which the first character of the identifier of the declared object appears.
> The value 0 indicates that no source line has been specified."


## DW\_AT\_declaration <!--- TODO: Implement check for this flag -->
TODO: add description or use case.

This is partly how `DW_AT_declaration` is described in DWARF 4, page 69:

> "A `DW_AT_declaration` attribute, which is a flag that indicates whether this entry represents a non-defining declaration of an object."


## DW\_AT\_default\_value <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_default_value` is described in DWARF 4, page 70:

> "A `DW_AT_default_value` attribute for a formal parameter entry.
> The value of this attribute is a reference to the debugging information entry for a variable or subroutine, or the value may be a constant.
> If the attribute form is of class reference, the default value of the parameter is the value of the referenced variable (which may be constant) or the value returned by the referenced subroutine; a reference value of 0 means that no default value has been specified.
> If the value is of class constant, that constant is interpreted as a default value of the type of the formal parameter."


## DW\_AT\_description <!--- NOTE: Not needed for my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_description` is described in DWARF 4, page 41:

> "Generally, any debugging information entry that has, or may have, a `DW_AT_name` attribute, may also have a `DW_AT_description` attribute whose value is a null-terminated string providing a description of the entity."


## DW\_AT\_digit\_count <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_digit_count` is described in DWARF 4, page 78:

> "The `DW_AT_digit_count` attribute is an integer constant value that represents the number of digits in an instance of the type."


## DW\_AT\_discr <!--- NOTE: Used in my debugger -->
The attribute `DW_at_discr` can always be found in dies with the tag `DW_TAG_variant_part`.
The value of this attribute is a reference to a type die, the type die can then be evaluated into a integer.
This integer can be matched to one of the child dies `DW_AT_discr_value` attribute.
The matching child is the variant of the variable.

This is partly how `DW_AT_discr` is described in DWARF 4, page 94:

> "If the variant part has a discriminant, the discriminant is represented by a separate debugging information entry which is a child of the variant part entry.
> This entry has the form of a structure data member entry.
> The variant part entry will have a `DW_AT_discr` attribute whose value is a reference to the member entry for the discriminant."


## DW\_AT\_discr\_list <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_discr_list` is described in DWARF 4, page 94:

> "Alternatively, the variant entry may contain a `DW_AT_discr_list` attribute, whose value represents a list of discriminant values.
> This list is represented by any of the block forms and may contain a mixture of case labels and label ranges.
> Each item on the list is prefixed with a discriminant value descriptor that determines whether the list item represents a single label or a label range.
> A single case label is represented as an LEB128 number as defined above for the `DW_AT_discr_value` attribute.
> A label range is represented by two LEB128 numbers, the low value of the range followed by the high value.
> Both values follow the rules for signedness just described.
> The discriminant value descriptor is an integer constant that may have one of the values given in Figure 17."


## DW\_AT\_discr\_value <!--- NOTE: Used in my debugger -->
This attribute can always be found in dies with tag `DW_TAG_variant` and those dies are always children of dies with the tag `DW_TAG_variant_part`.
The value of this attribute is always a integer that is used to match to the variant evaluated in the parent die.
If it matches then the child of this die describes the type of the current variant the variable is.

This is partly how `DW_AT_discr_value` is described in DWARF 4, page 94:

> "Each variant of a particular variant part is represented by a debugging information entry with the tag `DW_TAG_variant` and is a child of the variant part entry.
> The value that selects a given variant may be represented in one of three ways.
> The variant entry may have a `DW_AT_discr_value` attribute whose value represents a single case label.
> The value of this attribute is encoded as an LEB128 number.
> The number is signed if the tag type for the variant part containing this variant is a signed type.
> The number is unsigned if the tag type is an unsigned type."


## DW\_AT\_elemental <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_elemental` is described in DWARF 4, page 54:

> "A subprogram entry may have a `DW_AT_elemental` attribute, which is a flag.
> The attribute indicates whether the subroutine or entry point was declared with the “elemental” keyword or property."


## DW\_AT\_encoding <!--- NOTE: Used in my debugger -->
The attribute `DW_AT_encoding` can be found in dies with the tag `DW_TAG_base_type`.
It describes how the value of the base type should be interpreted in combination with the `DW_AT_byte_size`.
An example can be that the encoding says a integer is signed and the byte size is 4, then the base type value should be interpreted as a **i32** in rust.

This is partly how `DW_AT_encoding` is described in DWARF 4, page 75:

> "A base type entry has a `DW_AT_encoding` attribute describing how the base type is encoded and is to be interpreted.
> The value of this attribute is an integer constant.
> The set of values and their meanings for the `DW_AT_encoding` attribute is given in Figure 13 and following text."


## DW\_AT\_endianity <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_endianity` is described in DWARF 4, page 75:

> "A base type entry may have a `DW_AT_endianity` attribute as described in Section 4.1.
> If omitted, the encoding assumes the representation that is the default for the target architecture."


## DW\_AT\_entry\_pc <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_entry_pc` is described in DWARF 4, page 40:

> "Any debugging information entry describing an entity that has a range of code addresses, which includes compilation units, module initialization, subroutines, ordinary blocks, try/catch blocks, and the like, may have a `DW_AT_entry_pc` attribute to indicate the first executable instruction within that range of addresses.
> The value of the `DW_AT_entry_pc` attribute is a relocated address.
> If no `DW_AT_entry_pc` attribute is present, then the entry address is assumed to be the same as the value of the `DW_AT_low_pc` attribute, if present; otherwise, the entry address is unknown."


## DW\_AT\_enum\_class <!--- TODO: Confirm that it is not needed and update text -->
I don't really understand what this attribute is for.

This is partly how `DW_AT_enum_class` is described in DWARF 4, page 96:

> "If an enumeration type has type safe semantics such that
> 1. Enumerators are contained in the scope of the enumeration type, and/or
> 2. Enumerators are not implicitly converted to another type
> <br></br>
> then the enumeration type entry may have a `DW_AT_enum_class` attribute, which is a flag.
> In a language that offers only one kind of enumeration declaration, this attribute is not required."


## DW\_AT\_explicit <!--- NOTE: Not needed for my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_explicit` is described in DWARF 4, page 92:

> "If the member function entry describes an explicit member function, then that entry has a `DW_AT_explicit` attribute."


## DW\_AT\_extension <!--- NOTE: Not needed for my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_extension` is described in DWARF 4, page 49:

> "A namespace is represented by a debugging information entry with the tag `DW_TAG_namespace`.
> A namespace extension is represented by a `DW_TAG_namespace` entry with a `DW_AT_extension` attribute referring to the previous extension, or if there is no previous extension, to the original `DW_TAG_namespace` entry.
> A namespace extension entry does not need to duplicate information in a previous extension entry of the namespace nor need it duplicate information in the original namespace entry.
> (Thus, for a namespace with a name, a `DW_AT_name` attribute need only be attached directly to the original `DW_TAG_namespace` entry.)"


## DW\_AT\_external <!--- TODO: Use this to show visibility of functions and variables -->
This attributes is to show if a function or variable is visible outside of its compilation unit.
It can be found in dies with the tags `DW_TAG_subprogram` and `DW_TAG_variable`.

This is partly how `DW_AT_external` is described in DWARF 4, page 53:

> "If the name of the subroutine described by an entry with the tag `DW_TAG_subprogram` is visible outside of its containing compilation unit, that entry has a `DW_AT_external` attribute, which is a flag."

This is partly how `DW_AT_external` is described in DWARF 4, page 70:

> "If the variable entry represents a non-defining declaration, `DW_AT_specification` may be used to reference the defining declaration of the variable.
> If no `DW_AT_specification` attribute is present, the defining declaration may be found as a global definition either in the current compilation unit or in another compilation unit with the `DW_AT_external` attribute."


## DW\_AT\_frame\_base <!--- NOTE: Used in my debugger -->
In Rust this attribute can always be found in the dies with the tag `DW_TAG_subprogram`.
It is used when evaluating the value of variables that are in the subprogram.

This is partly how `DW_AT_frame_base` is described in DWARF 4, page 56:

> "A subroutine or entry point entry may also have a `DW_AT_frame_base` attribute, whose value is a location description that computes the “frame base” for the subroutine or entry point.
> If the location description is a simple register location description, the given register contains the frame base address.
> If the location description is a DWARF expression, the result of evaluating that expression is the frame base address.
> Finally, for a location list, this interpretation applies to each location description contained in the list of location list entries."


## DW\_AT\_friend <!--- NOTE: Not applicable for my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_friend` is described in DWARF 4, page 87:

> "A friend entry has a `DW_AT_friend` attribute, whose value is a reference to the debugging information entry describing the declaration of the friend."


## DW\_AT\_high\_pc <!--- TODO: Use this to know the end address of subprogram -->
This attribute is used to find out what the highest pc value a subprogram, module or some other code block has.

This is partly how `DW_AT_high_pc` is described in DWARF 4, page 37:

> "A `DW_AT_low_pc` and `DW_AT_high_pc` pair of attributes for a single contiguous range of addresses, or"


## DW\_AT\_identifier\_case <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_identifier_case` is described in DWARF 4, page 46:

> "A `DW_AT_identifier_case` attribute whose integer constant value is a code describing the treatment of identifiers within this compilation unit.
> The set of identifier case codes is given in Figure 9."


## DW\_AT\_import <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_import` is described in DWARF 4, page 47:

> "The place where a normal or partial unit is imported is represented by a debugging information entry with the tag `DW_TAG_imported_unit`.
> An imported unit entry contains a `DW_AT_import` attribute whose value is a reference to the normal or partial compilation unit whose declarations logically belong at the place of the imported unit entry."


## DW\_AT\_inline <!--- TODO: Used this to show what functions got inlined -->
This attribute can be used in to ways, the first is to declare an instance abstract, the other way so to describe if a function got inlined or not. 

This is partly how **Abstract Instances** is described in DWARF 4, page 59:

> "Any debugging information entry that is owned (either directly or indirectly) by a debugging information entry that contains the `DW_AT_inline` attribute is referred to as an “abstract instance entry.”
> Any subroutine entry that contains a `DW_AT_inline` attribute whose value is other than `DW_INL_not_inlined` is known as an “abstract instance root.”"

This is how **Inlined Subroutines** is described in DWARF 4, page 58:

> "A declaration or a definition of an inlinable subroutine is represented by a debugging information entry with the tag `DW_TAG_subprogram`.
> The entry for a subroutine that is explicitly declared to be available for inline expansion or that was expanded inline implicitly by the compiler has a `DW_AT_inline` attribute whose value is an integer constant.
> The set of values for the `DW_AT_inline` attribute is given in Figure 11."


## DW\_AT\_is\_optional <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_is_optional` is described in DWARF 4, page 70:

> "A `DW_AT_is_optional` attribute, which is a flag, if a parameter entry represents an optional parameter."


## DW\_AT\_language <!--- TODO: Use to check that Rust is the source language for the compile unit. -->
This can be used to see what source language the compilation unit was written in and thus this attribute can be found in dies with the tag `DW_TAG_compile_unit`.

This is partly how `DW_AT_language` is described in DWARF 4, page 44:

> "A `DW_AT_language` attribute whose constant value is an integer code indicating the source language of the compilation unit.
> The set of language names and their meanings are given in Figure 8."


## DW\_AT\_linkage\_name <!--- TODO: Find out what this can be used for -->
This attribute is found in most dies that also have the attribute `DW_AT_name`.

This is partly how `DW_AT_linkage_name` is described in DWARF 4, page 41:

> "A debugging information entry may have a `DW_AT_linkage_name` attribute whose value is a null-terminated string describing the object file linkage name associated with the corresponding entity."


## DW\_AT\_location <!--- NOTE: Used in my debugger. -->
The attribute `DW_AT_location` is used to get the value of an variable, parameter and more.
This is done by evaluating the location information into DWARF pieces, these pieces hold the location of the value or the value it self. 
But it does not hold the type information thus the variable needs to be parsed using the pieces and the type information.

This attribute is found in dies with the tag `DW_TAG_variable` for example and those dies usually also have a attribute called `DW_AT_type` which holds the type information.
But When debugging optimized code the attribute `DW_AT_type` is not always in the same die and the reason for this is that the variable has been inlined.
These dies will have a attribute `DW_AT_abstract_origin` instead which points to the original variable die that has the type attribute.

This is partly how `DW_AT_location` is described in DWARF 4, page 37:

> "Any debugging information entry describing a data object (which includes variables and parameters) or common block may have a `DW_AT_location` attribute, whose value is a location description (see Section 2.6)."


## DW\_AT\_low\_pc <!--- TODO: Use this to know the start address of subprogram -->
This attribute is used to find out what the lowest pc value a subprogram, module or some other code block has.

This is partly how `DW_AT_low_pc` is described in DWARF 4, page 37:

> "• A `DW_AT_low_pc` attribute for a single address,
> • A `DW_AT_low_pc` and `DW_AT_high_pc` pair of attributes for a single contiguous range of addresses, or"


## DW\_AT\_lower\_bound <!--- TODO: Use this when evaluating subrange dies and update text -->
This is partly how `DW_AT_lower_bound` is described in DWARF 4, page 99:

> "The subrange entry may have the attributes `DW_AT_lower_bound` and `DW_AT_upper_bound` to specify, respectively, the lower and upper bound values of the subrange.
> The `DW_AT_upper_bound` attribute may be replaced by a `DW_AT_count` attribute, whose value describes the number of elements in the subrange rather than the value of the last element.
> The value of each of these attributes is determined as described in Section 2.19."


## DW\_AT\_macro\_info <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_macro_info` is described in DWARF 4, page 45:

> "A `DW_AT_macro_info` attribute whose value is a section offset to the macro information for this compilation unit."


## DW\_AT\_main\_subprogram <!--- TODO: Check if this can be useful. -->
This attribute is a flag that indicates that the function this is present in is the starting point for the program.
The attribute can be found in the dies with the tag `DW_TAG_subprogram`.

This is partly how `DW_AT_main_subprogram` is described in DWARF 4, page 47:

> "A `DW_AT_main_subprogram` attribute, which is a flag whose presence indicates that the compilation unit contains a subprogram that has been identified as the starting function of the program.
> If more than one compilation unit contains this flag, any one of them may contain the starting function."


## DW\_AT\_mutable <!--- Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_mutable` is described in DWARF 4, page 47:

> "A data member entry may have a `DW_AT_mutable` attribute, which is a flag.
> This attribute indicates whether the data member was declared with the mutable storage class specifier."


## DW\_AT\_name <!--- NOTE: Used in my debugger -->
The value of this attribute is the source name of the thing that the die is representing from the source code.
Thus many of the dies have this attribute because most of the dies represents a named thing in the source code.

This is partly how `DW_AT_name` is described in DWARF 4, page 36:

> "Any debugging information entry representing a program entity that has been given a name may have a `DW_AT_name` attribute, whose value is a string representing the name as it appears in the source program.
> A debugging information entry containing no name attribute, or containing a name attribute whose value consists of a name containing a single null byte, represents a program entity for which no name was given in the source."


## DW\_AT\_namelist\_item <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_namelist_item` is described in DWARF 4, page 73:

> "Each namelist item entry contains a `DW_AT_namelist_item` attribute whose value is a reference to the debugging information entry representing the declaration of the item whose name appears in the namelist."


## DW\_AT\_object\_pointer <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_object_pointer` is described in DWARF 4, page 92:

> "If the member function entry describes a non-static member function, then that entry has a `DW_AT_object_pointer` attribute whose value is a reference to the formal parameter entry that corresponds to the object for which the function is called.
> The name attribute of that formal parameter is defined by the current language (for example, this for C++ or self for Objective C and some other languages).
> That parameter also has a `DW_AT_artificial` attribute whose value is true. 


## DW\_AT\_ordering <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_ordering` is described in DWARF 4, page 82:

> "The array type entry describing a multidimensional array may have a `DW_AT_ordering` attribute whose integer constant value is interpreted to mean either row-major or column-major ordering of array elements.
> The set of values and their meanings for the ordering attribute are listed in Figure 16.
> If no ordering attribute is present, the default ordering for the source language (which is indicated by the `DW_AT_language` attribute of the enclosing compilation unit entry) is assumed."


## DW\_AT\_picture\_string <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_picture_string` is described in DWARF 4, page 78:

> "The `DW_ATE_edited` base type is used to represent an edited numeric or alphanumeric data type.
> It is used in combination with an `DW_AT_picture_string` attribute whose value is a null-terminated string containing the target-dependent picture string associated with the type."


## DW\_AT\_priority <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_priority` is described in DWARF 4, page 49:

> "If the module has been assigned a priority, it may have a `DW_AT_priority` attribute.
> The value of this attribute is a reference to another debugging information entry describing a variable with a constant value.
> The value of this variable is the actual constant value of the module’s priority, represented as it would be on the target architecture."


## DW\_AT\_producer <!--- TODO: Use this attribute in my debugger somehow. -->
Describes which compiler that generated this DWARF compilation unit and which version of the compiler that was used.
This attributes is only found in the dies with the tag `DW_TAG_compile_unit`.

This is partly how `DW_AT_producer` is described in DWARF 4, page 46:

> "A `DW_AT_producer` attribute whose value is a null-terminated string containing information about the compiler that produced the compilation unit.
> The actual contents of the string will be specific to each producer, but should begin with the name of the compiler vendor or some other identifying character sequence that should avoid confusion with other producer values."


## DW\_AT\_prototyped <!--- NOTE: Not applicable to my debugger -->
This seams to be a thing in **C** functions and thus is not used in rust.

This is partly how `DW_AT_prototyped` is described in DWARF 4, page 54:

> "A subroutine entry declared with a function prototype style declaration may have a `DW_AT_prototyped` attribute, which is a flag."

This is partly how `DW_AT_prototyped` is described in DWARF 4, page 97:

> "A subroutine entry declared with a function prototype style declaration may have a `DW_AT_prototyped` attribute, which is a flag."


## DW\_AT\_pure <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_pure` is described in DWARF 4, page 55:

> "A subprogram entry may have a `DW_AT_pure` attribute, which is a flag.
> The attribute indicates whether the subroutine was declared with the “pure” keyword or property."


## DW\_AT\_ranges <!--- TODO: Find use of this in my debugger -->
This attributes holds the pc ranges for when this code block is executing and can thus be used to know if the program is currently executing the code of this function.

This is partly how `DW_AT_pure` is described in DWARF 4, page 38:

> "When the set of addresses of a debugging information entry cannot be described as a single contiguous range, the entry has a `DW_AT_ranges` attribute whose value is of class rangelistptr and indicates the beginning of a range list.
> Similarly, a `DW_AT_start_scope` attribute may have a value of class rangelistptr for the same reason."


## DW\_AT\_recursive <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_recursive` is described in DWARF 4, page 54:

> "A subprogram entry may have a `DW_AT_recursive` attribute, which is a flag.
> The attribute indicates whether the subroutine or entry point was declared with the “recursive” keyword or property."


## DW\_AT\_return\_addr <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_return_addr` is described in DWARF 4, page 56:

> "A subroutine or entry point entry may have a `DW_AT_return_addr` attribute, whose value is a location description.
> The location calculated is the place where the return address for the subroutine or entry point is stored."


## DW\_AT\_segment <!--- NOTE: Not applicable to my debugger -->
This seems to not be used by Rust.

This is partly how `DW_AT_segment` is described in DWARF 4, page 34:

> "Any debugging information entry that contains a description of the location of an object or subroutine may have a `DW_AT_segment` attribute, whose value is a location description.
> The description evaluates to the segment selector of the item being described.
> If the entry containing the `DW_AT_segment` attribute has a `DW_AT_low_pc`, `DW_AT_high_pc`, `DW_AT_ranges` or `DW_AT_entry_pc` attribute, or a location description that evaluates to an address, then those address values represent the offset portion of the address within the segment specified by `DW_AT_segment`."


## DW\_AT\_sibling <!--- TODO: Use to quickly go through siblings. -->
This attributes is used for quickly accessing siblings of a die.
Which is easier and faster then finding the parent and going through all of the parents children.

This is partly how `DW_AT_sibling` is described in DWARF 4, page 16:

> "In cases where a producer of debugging information feels that it will be important for consumers of that information to quickly scan chains of sibling entries, while ignoring the children of individual siblings, that producer may attach a `DW_AT_sibling` attribute to any debugging information entry.
> The value of this attribute is a reference to the sibling entry of the entry to which the attribute is attached."


## DW\_AT\_small <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_small` is described in DWARF 4, page 79:

> "For a data type with a non-decimal and non-binary scale factor, the fixed binary type entry has a `DW_AT_small` attribute which references a `DW_TAG_constant` entry.
> The scale factor value is interpreted in accordance with the value defined by the `DW_TAG_constant` entry.
> The value represented is the product of the integer value in memory and the associated constant entry for the type."


## DW\_AT\_signature <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_signature` is described in DWARF 4, page 85:

> "If the complete declaration of a type has been placed in a separate type unit (see Section 3.1.3), an incomplete declaration of that type in the compilation unit may provide the unique 64-bit signature of the type using a `DW_AT_signature` attribute."


## DW\_AT\_specification <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_specification` is described in DWARF 4, page 36:

> "A debugging information entry that represents a declaration that completes another (earlier) nondefining declaration may have a `DW_AT_specification` attribute whose value is a reference to the debugging information entry representing the non-defining declaration.
> A debugging information entry with a `DW_AT_specification` attribute does not need to duplicate information provided by the debugging information entry referenced by that specification attribute.
> <br></br>
> It is not the case that all attributes of the debugging information entry referenced by a `DW_AT_specification` attribute apply to the referring debugging information entry."


## DW\_AT\_start\_scope <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_start_scope` is described in DWARF 4, page 71:

> " A `DW_AT_start_scope` attribute if the scope of an object is smaller than (that is, is a subset of the addresses of) the scope most closely enclosing the object.
> There are two cases:
> <br></br>
> a) If the scope of the object entry includes all of the containing scope except for a contiguous sequence of bytes at the beginning of that containing scope, then the scope of the object is specified using a value of class constant.
> If the containing scope is contiguous, the value of this attribute is the offset in bytes of the beginning of the scope for the object from the low pc value of the debugging information entry that defines its scope.
> If the containing scope is non-contiguous (see Section 2.17.3), the value of this
attribute is the offset in bytes of the beginning of the scope for the object from the beginning of the first range list entry that is not a base selection entry or an end of list entry.
> <br></br>
> b) Otherwise, the scope of the object is specified using a value of class rangelistptr.
> This value indicates the beginning of a range list (see Section 2.17.3)."


## DW\_AT\_static\_link <!--- TODO: Confirm -->
This seems to not be used by Rust.

This is partly how `DW_AT_static_link` is described in DWARF 4, page 57:

> "If a subroutine or entry point is nested, it may have a `DW_AT_static_link` attribute, whose value is a location description that computes the frame base of the relevant instance of the subroutine that immediately encloses the subroutine or entry point."


## DW\_AT\_stmt\_list <!--- NOTE: I use unit.line_program from gimli-rs instead -->
This attribute is only found in dies with the tag `DW_TAG_compile_unit` and its value is a offset to the line number information.

This is partly how `DW_AT_stmt_list` is described in DWARF 4, page 45:

> "A `DW_AT_stmt_list` attribute whose value is a section offset to the line number information for this compilation unit.
> This information is placed in a separate object file section from the debugging information entries themselves.
> The value of the statement list attribute is the offset in the .debug\_line section of the first byte of the line number information for this compilation unit (see Section 6.2)."


## DW\_AT\_string\_length <!--- NOTE: Not applicable to my debugger -->
Doesn't seem to be used by Rust.

This is partly how `DW_AT_string_length` is described in DWARF 4, page 98:

> "The string type entry may have a `DW_AT_string_length` attribute whose value is a location description yielding the location where the length of the string is stored in the program."


## DW\_AT\_threads\_scaled <!--- TODO: Confirm -->
Doesn't seem to be used by Rust.

This is partly how `DW_AT_threads_scaled` is described in DWARF 4, page 99:

> "The subrange entry may have a `DW_AT_threads_scaled` attribute, which is a flag.
> If present, this attribute indicates whether this subrange represents a UPC array bound which is scaled by the runtime THREADS value (the number of UPC threads in this execution of the program)."


## DW\_AT\_trampoline <!--- TODO: Confirm -->
Doesn't seem to be used by Rust.

This is partly how `DW_AT_trampoline` is described in DWARF 4, page 64:

> "A trampoline is represented by a debugging information entry with the tag `DW_TAG_subprogram` or `DW_TAG_inlined_subroutine` that has a `DW_AT_trampoline` attribute.
> The value of that attribute indicates the target subroutine of the trampoline, that is, the subroutine to which the trampoline passes control.
> (A trampoline entry may but need not also have a `DW_AT_artificial` attribute.)"


## DW\_AT\_type <!--- NOTE: Used in my debugger -->
The dies with a value like the ones with tag `DW_AT_variable` will also have a type that is represented by a tree of type dies.
Thus most of those dies will have the attribute `DW_AT_type` which points to the root die of the type tree.
The type tree is used to parse addresses and values into the variables true value.

This is partly how `DW_AT_type` is described in DWARF 4, page 32:

> "Any debugging information entry describing a declaration that has a type has a `DW_AT_type` attribute, whose value is a reference to another debugging information entry.
> The entry referenced may describe a base type, that is, a type that is not defined in terms of other data types, or it may describe a user-defined type, such as an array, structure or enumeration.
> Alternatively, the entry referenced may describe a type modifier, such as constant, packed, pointer, reference or volatile, which in turn will reference another entry describing a type or type modifier (using a `DW_AT_type` attribute of its own).
> See Section for descriptions of the entries describing base types, user-defined types and type modifiers."


## DW\_AT\_upper\_bound <!--- TODO: Confirm -->
I have never encounter it when debugging Rust code, but I think that this attribute can be present when debugging Rust code.

This is partly how `DW_AT_upper_bound` is described in DWARF 4, page 99:

> "The subrange entry may have the attributes `DW_AT_lower_bound` and `DW_AT_upper_bound` to specify, respectively, the lower and upper bound values of the subrange.
> The `DW_AT_upper_bound` attribute may be replaced by a `DW_AT_count` attribute, whose value describes the number of elements in the subrange rather than the value of the last element.
> The value of each of these attributes is determined as described in Section 2.19."


## DW\_AT\_use\_location <!--- TODO: Investigate -->
I have never encounter it when debugging Rust code, but I think that this attribute can be present when debugging Rust code.

This is partly how `DW_AT_use_location` is described in DWARF 4, page 100:

> "The pointer to member entry has a `DW_AT_use_location` attribute whose value is a location description that computes the address of the member of the class to which the pointer to member entry points."


## DW\_AT\_use\_UTF8 <!--- TODO: Investigate -->
I have never encounter it when debugging Rust code, but I think that this attribute can be present when debugging Rust code.

This is partly how `DW_AT_use_UTF8` is described in DWARF 4, page 47:

> "A `DW_AT_use_UTF8` attribute, which is a flag whose presence indicates that all strings (such as the names of declared entities in the source program) are represented using the UTF-8 representation (see Section 7.5.4)."


## DW\_AT\_variable\_parameter <!--- TODO: Confirm -->
Doesn't seem to be used by Rust.

This is partly how `DW_AT_variable_parameter` is described in DWARF 4, page 70:

> "A `DW_AT_variable_parameter` attribute, which is a flag, if a formal parameter entry represents a parameter whose value in the calling function may be modified by the callee..
> The absence of this attribute implies that the parameter’s value in the calling function cannot be modified by the callee."


## DW\_AT\_virtuality <!--- NOTE: Not applicable to my debugger -->
Doesn't seem to be used by Rust.

This is partly how `DW_AT_virtuality` is described in DWARF 4, page 33:

> "The virtuality of a declaration is represented by a `DW_AT_virtuality` attribute, whose value is a constant drawn from the set of codes listed in Figure 6."


## DW\_AT\_visibility <!--- NOTE: Not applicable to my debugger -->
Doesn't seem to be used by Rust.

This is partly how `DW_AT_visibility` is described in DWARF 4, page 33:

> "The visibility of a declaration is represented by a `DW_AT_visibility` attribute, whose value is a constant drawn from the set of codes listed in Figure 5. 


## DW\_AT\_vtable\_elem\_location <!--- TODO: Confirm -->
Doesn't seem to be used by Rust.

This is partly how `DW_AT_vtable_elem_location` is described in DWARF 4, page 92:

> "An entry for a virtual function also has a `DW_AT_vtable_elem_location` attribute whose value contains a location description yielding the address of the slot for the function within the virtual function table for the enclosing class.
> The address of an object of the enclosing type is pushed onto the expression stack before the location description is evaluated."

